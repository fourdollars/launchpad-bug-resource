#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

clearup ()
{
    if [ "$debug" = "false" ]; then
        rm -f "$tmp"
        rm -f /tmp/input.json
        rm -fr ~/.config/launchpad
    fi
}

trap clearup EXIT INT TERM

tmp=$(mktemp -u /tmp/json-XXXXXX)

exec 3>&1
exec 1>&2
jq -M -S . < /dev/stdin > /tmp/input.json

debug="$(jq -r '.source.debug // "false"' < /tmp/input.json)"

if [ "$0" = '/opt/resource/out' ]; then
    jq -n '{}' >&3  # noop
    exit
fi

if [ "$(jq -r '.source | has("oauth_consumer_key")' < /tmp/input.json)" = 'true' ]; then
    oauth_consumer_key="$(jq -r .source.oauth_consumer_key < /tmp/input.json)"
else
    echo 'You need to provide the oauth_consumer_key.'
    exit 1
fi

if [ "$(jq -r '.source | has("oauth_token")' < /tmp/input.json)" = 'true' ]; then
    oauth_token="$(jq -r .source.oauth_token < /tmp/input.json)"
else
    echo 'You need to provide the oauth_token.'
    exit 1
fi

if [ "$(jq -r '.source | has("oauth_token_secret")' < /tmp/input.json)" = 'true' ]; then
    oauth_token_secret="$(jq -r .source.oauth_token_secret < /tmp/input.json)"
else
    echo 'You need to provide the oauth_token_secret.'
    exit 1
fi

mkdir -p ~/.config/launchpad
cat > ~/.config/launchpad/"$oauth_consumer_key" <<ENDLINE
#!/bin/bash

export oauth_token="${oauth_token}"
export oauth_token_secret="${oauth_token_secret}"
ENDLINE

if [ "$debug" = "verbose" ]; then
    set -x
fi

if [ "$(jq -r '.source | has("id")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.id | type' < /tmp/input.json)" in
        ('number')
            id=("$(jq -r .source.id < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t id < <(jq -r '.source.id | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.id"
            exit 1
            ;;
    esac
else
    id=()
fi

if [ "$(jq -r '.source | has("status")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.status | type' < /tmp/input.json)" in
        ('string')
            status=("$(jq -r .source.status < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t status < <(jq -r '.source.status | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.status"
            exit 1
            ;;
    esac
else
    status=()
fi

if [ "$(jq -r '.source | has("project")' < /tmp/input.json)" = 'true' ]; then
    project="$(jq -r .source.project < /tmp/input.json)"
else
    project=''
fi

if [ "$(jq -r '.source | has("tag")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.tag | type' < /tmp/input.json)" in
        ('number')
            tag=("$(jq -r '.source.tag' < /tmp/input.json)")
            ;;
        ('string')
            tag=("$(jq -r '.source.tag' < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t tag < <(jq -r '.source.tag|.[]' < /tmp/input.json | sort)
            ;;
        (*)
            echo "Type '$(jq -r '.source.tag | type' < /tmp/input.json)' input is invalid for .source.tag"
            exit 1
            ;;
    esac
else
    tag=()
fi

auto_mode="$(jq -r '.source.auto_mode // "false"' < /tmp/input.json)"
parallel="$(jq -r '.source.parallel // "false"' < /tmp/input.json)"
modified_since="$(jq -r '.source.modified_since // ""' < /tmp/input.json)"
created_since="$(jq -r '.source.created_since // ""' < /tmp/input.json)"
created_before="$(jq -r '.source.created_before // ""' < /tmp/input.json)"
old_date_last_updated="$(jq -r '.version.date_last_updated // ""' < /tmp/input.json)"
old_modified_since="$(jq -r '.version.modified_since // ""' < /tmp/input.json)"

# Backward Compatibility
if [ -n "$modified_since" ] && [ "$modified_since" = "auto" ]; then
    auto_mode="true"
    modified_since=""
fi

if [ "$(jq -r '.version | has("digest")' < /tmp/input.json)" = 'true' ]; then
    digest="$(jq -r '.version.digest' < /tmp/input.json)"
else
    digest=''
fi

case "$0" in
    ('/opt/resource/in')
        cd "$1"
        mkdir tasks
        ;;
esac

declare -A etag=()
declare -A title=()
declare -a args=()

for name in "${tag[@]}"; do
    args+=("tags==$name")
done

if [ -n "${tag[*]}" ]; then
    case "$(jq -r '.source.combinator // "any"' < /tmp/input.json)" in
        (all)
            args+=('tags_combinator==All')
            ;;
        (any)
            args+=('tags_combinator==Any')
            ;;
    esac
fi

if [ "$auto_mode" = 'true' ]; then
    if [ "$0" = /opt/resource/check ] && [ -n "$old_date_last_updated" ]; then
        args+=("modified_since==$old_date_last_updated")
    elif [ "$0" = /opt/resource/in ] && [ -n "$old_modified_since" ]; then
        args+=("modified_since==$old_modified_since")
    elif [ -n "$modified_since" ]; then
        args+=("modified_since==$modified_since")
    fi
elif [ -n "$modified_since" ]; then
    args+=("modified_since==$modified_since")
fi

if [ -n "$created_since" ]; then
    args+=("created_since==$created_since")
fi

if [ -n "$created_before" ]; then
    args+=("created_before==$created_before")
fi

for name in "${status[@]}"; do
    case "$name" in
        ("New"|"Incomplete"|"Opinion"|"Invalid"|"Won't Fix"|"Expired"|"Confirmed"|"Triaged"|"In Progress"|"Fix Committed"|"Fix Released")
            args+=("status==$name")
            ;;
        ('*')
            args+=("New" "Incomplete" "Opinion" "Invalid" "Won't Fix" "Expired" "Confirmed" "Triaged" "In Progress" "Fix Committed" "Fix Released")
            ;;
        (*)
            echo "$name is not a valid status."
            exit 1
            ;;
    esac
done

if [ -n "$project" ]; then
    echo launchpad-api get "$project" ws.op==searchTasks "${args[@]}"
    oauth_consumer_key="$oauth_consumer_key" launchpad-api get "$project" ws.op==searchTasks "${args[@]}" > "$tmp"

    if [ "$(jq -r 'has("total_size_link")' < "$tmp")" = "true" ]; then
        echo "Total: $(http get "$(jq -r '.total_size_link' < "$tmp")")"
    else
        echo "Total: $(jq -r '.total_size' < "$tmp")"
    fi

    while read -r bug_link; do
        id+=("$(basename "$bug_link")")
    done < <(jq -r '.entries | .[] | .bug_link' < "$tmp")
    echo -en "\rCollected ${#id[@]} IDs"

    next=$(jq -r .next_collection_link < "$tmp")
    while [ "$next" != 'null' ]; do
        http --ignore-stdin --check-status --follow "$next" > "$tmp"
        while read -r bug_link; do
            id+=("$(basename "$bug_link")")
        done < <(jq -r '.entries | .[] | .bug_link' < "$tmp")
        echo -en "\rCollected ${#id[@]} IDs"
        next=$(jq -r .next_collection_link < "$tmp")
    done
    echo ""
fi

if [ -z "${id[*]}" ]; then
    case "$0" in
        ('/opt/resource/check')
            if [ "$auto_mode" = 'true' ]; then
                json='[{"digest":"'"$digest"'","date_last_updated":"'"$old_date_last_updated"'","modified_since":"'"$old_modified_since"'"}]'
            else
                json='[{"digest":"'"$digest"'"}]'
            fi
            ;;
        ('/opt/resource/in')
            if [ "$auto_mode" = 'true' ]; then
                json='{"version":{"digest":"'"$digest"'","date_last_updated":"'"$old_date_last_updated"'","modified_since":"'"$old_modified_since"'"}}'
            else
                json='{"version":{"digest":"'"$digest"'"}}'
            fi
            ;;
    esac
    jq -n "$json" >&3
    exit
fi

mapfile -t bugs < <(sort -u -n <<<"${id[*]}")

if [ "$auto_mode" = 'true' ]; then
    if [ -n "$old_date_last_updated" ]; then
        new_modified_since="$old_date_last_updated"
    else
        new_modified_since=''
    fi
fi

if [ "$parallel" = "true" ]; then
    parallel "echo \"Fetching bugs/{}\"; oauth_consumer_key=\"$oauth_consumer_key\" launchpad-api get bugs/{} > {}.json" ::: "${bugs[@]}"
    if [ -d tasks ]; then
        parallel "echo \"Fetching tasks/{}\"; oauth_consumer_key=\"$oauth_consumer_key\" launchpad-api get bugs/{}/bug_tasks > tasks/{}.json" ::: "${bugs[@]}"
    fi
else
    for idx in "${!bugs[@]}"; do
        echo -en "\rFetching $((idx + 1))/${#bugs[@]} IDs"
        bug="${bugs[$idx]}"
        oauth_consumer_key="$oauth_consumer_key" launchpad-api get bugs/"$bug" > "$bug".json
        if [ -d tasks ]; then
            oauth_consumer_key="$oauth_consumer_key" launchpad-api get bugs/"$bug"/bug_tasks > tasks/"$bug".json
        fi
    done
fi

new_date_last_updated=''
for bug in "${bugs[@]}"; do
    etag[$bug]=$(jq -r .http_etag < "$bug".json)
    title[$bug]=$(jq -r .title < "$bug".json | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')
    if [ "$auto_mode" = 'true' ]; then
        last_updated="$(jq -r .date_last_updated < "$bug".json)"
        if [[ "$last_updated" > "$new_date_last_updated" ]]; then
            new_date_last_updated="$last_updated"
        fi
    fi
done

digest="sha256:$(echo "${id[@]}" "${etag[@]}" | sha256sum | awk '{print $1}')"

case "$0" in
    ('/opt/resource/check')
        if [ "$auto_mode" = 'true' ]; then
            json="$(cat <<ENDLINE
[
    {
        "digest": "$digest",
        "date_last_updated": "$new_date_last_updated",
        "modified_since": "$new_modified_since"
    }
]
ENDLINE
)"
        else
            json="$(cat <<ENDLINE
[
    {
        "digest": "$digest"
    }
]
ENDLINE
)"
        fi
        ;;
    ('/opt/resource/in')
        if [ "$auto_mode" = 'true' ]; then
            json="$(cat <<ENDLINE
{
    "version": {
        "digest": "$digest",
        "date_last_updated": "$new_date_last_updated",
        "modified_since": "$new_modified_since"
    },
    "metadata": [
ENDLINE
)"
        else
            json="$(cat <<ENDLINE
{
    "version": {
        "digest": "$digest"
    },
    "metadata": [
ENDLINE
)"
        fi
        for bug in "${bugs[@]}"; do
            json+="$(cat <<ENDLINE
        {
            "name": "$bug",
            "value": "${title[$bug]}"
        }
ENDLINE
)"
            if [ "$bug" != "${bugs[-1]}" ]; then
                json+=","
            fi
        done
        json+="$(cat <<ENDLINE
    ]
}
ENDLINE
)"
        ;;
esac

echo "$json" > "$tmp"
sed -i 's/\t/ /g' "$tmp"
jq -n --slurpfile all "$tmp" '$all[0]' >&3
